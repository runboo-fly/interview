# java se
## java intro
### java语言特点
- 面向对象，封装继承多态
- 支持多线程
- 异常处理和自动内存管理机制
### JVM、JDK、JRE
- JVM：java虚拟机是运行java字节码的，JVM根据不同的系统有不同的实现。目的是同样的字节码 即```.class```文件，JVM会给出相同的机器码。从```.class```——>机器码这一步，会根据代码是否是热点代码，不是热点代码则通过解释器逐行解释执行，是热点代码则通过JIT编译器，just-in-time compilation。当JIT完成第一次编译后，其会将字节码对应的机器码保存下来，下次直接使用。
- JRE：java runtime environment，是java运行时环境，包括JVM和java class library。
- JDK：java development kit，是提供给开发者使用的java sdk，除了JRE之外还包含将java源码即.java文件编译为字节码的编译器javac，以及jdb调试器，jconsole可视化监控工具等等
### 为什么说java语言编译与解释共存？
因为java程序先经过javac编译器编译，生成```.class```字节码文件，这种字节码必须由java解释器来解释执行。
### java与c++的区别
- java不提供指针直接访问内存，程序内存更加安全
- java有自动的内存管理垃圾回收机制，不需要手动释放无用内存
- java只有单继承，但可以实现接口的多继承
- ## java language basics
### 数据类型
| 基本类型 | 字节 | 位数 | 初始值|包装类 |
|---------|---------|---------|------|-----|
|byte| 1个字节 | 8位 |0|Byte|
|short| 2个字节|16位|0|Short|
|int| 4个字节|32位|0|Integer|
|long| 8个字节|64位|0L|Long|
|char| 2个字节|16位|'u0000'|Character|
|float |4 个字节|（32位）|0f|Float|
|double| 8 个字节|64|0d|Double|
|boolean||1|false|Boolean|

1.long类型的数据要在数值前加L
2.```char a='h'```,单引号；```String a="hello"```，双引号

### 基本类型和包装类型的差别
- 基本数据类型的局部变量存放在java虚拟机栈中的局部变量表，基本数据类型的成员变量（未被```static```修饰的）存放在java虚拟机堆中。包装类型属于对象类型，几乎所有对象实例都存放在堆中。

> 在成员变量中，推荐要么使用static修饰的基本数据类型，这会存放在栈中；要么使用包装类型，这会存放在堆中。
- 基本数据类型所占空间更小，都有初识默认值。包装类型的默认值都是null。
- 对于基本数据类型，```==```比较的是值。包装类```==```比较的是包装类对象的地址，所有的整型包装类值的比较用```equals()```

### 包装类型的缓存机制
- Byte、Short、Integer、Long这4个包装类，默认创建了[-128,127]数值相应类型的缓存数据
- char包装类，默认创建了数值在[0,127]的缓存数据，Boolean直接返回true或者false
- 两种浮点数类型的包装类Float、Double没有实现缓存机制
- ```Integer i1=40```这行代码会使用缓存中的对象，自动将int型转换为Integer，因此内存地址也是缓存中对象的地址
- ```Integer i2=new Integer(40)```会直接创建新的对象。因此i1==i2为false

### 拆箱与装箱
- 装箱：将基本类型转换为包装类，```Integer i=1；```，等价为```Integer i=Integer.valueOf(1);```
- 拆箱：将包装类转换为基本类型，```int n=i;```,等价为```int n=i.intValue()```
- 频繁拆箱和装箱会严重影响系统的性能

### 移位运算

int的最大值是2^31 -1,因为最高位来表示正负，其余31位都为1时最大，此时为2^31-1。
在计算机中，负数用补码表示，补码是取反再加一，负数的最高位都是1。
最大的负数为-2^31，补码为10000000000000000000000000000000。
最小的负数为-1，补码为11111111111111111111111111111111。

移位操作符实际上支持的类型只有int和long，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作。

-  ```<<```左移运算符，高位丢弃低位补0。x<<1，相当于x*2，在不溢出的情况下。
-  ```>>```带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补0，负数高位补1。x>>1，相当于除以2。

### 浮点数与大整数类型
- 浮点数会有精度丢失的情况，```BigDecimal```可以实现对浮点数的运算不会造成精度丢失。
- 在java中，64位long整型是最大的整数类型，超过这个范围就会有数值溢出的风险
- BigInteger内部使用int[]数组来存储任意大小的整型数据

### 成员变量和局部变量的区别
- 语法形式：成员变量可以被public、private、static等修饰符修饰；但局部变量不能被访问控制修饰符以及static修饰；但是，成员变量和局部变量都可以被final修饰。
- 局部变量保存在栈中，成员变量如果被static修饰则属于类，没有则属于实例，对象存在于堆中。
- 成员变量是对象的一部分，随着对象的创建而创建，局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。
- 成员变量一般自动以类型的默认值赋值，被final修饰的成员变量必须显式地赋值，局部变量不会自动赋值。

### 字符常量和字符串常量
- 字符常量是单引号，只占2个字节
- 字符串常量为双引号，占多个字节，代表字符串在内存中存放的位置

### 静态成员与静态方法
- 静态方法不能调用非静态成员
- 调用静态方法建议使用类名.方法名
- 静态方法只允许访问静态成员，不允许访问实例成员

### 重写与重载
- 重载，方法名相同，形参类型不同、个数不同、顺序不同。
- 重写，子类对父类，方法名和参数列表必须相同。返回值类型比父类小或相等，抛出的异常类比父类小或相等，子类的访问权限比父类方法的权限更大或相等。
- 重载时，可变长参数匹配度不如固定参数
